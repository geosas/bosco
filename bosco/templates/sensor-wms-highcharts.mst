{{#features}}
	<li id="{{feature_ol_uid}}" class="inventaire item el-{{feature_ol_uid}}" style="height: 330px; overflow:auto;">
        {{#observations}}
            <p>
                <b>Streams sélectionnés : </b> {{streamsNames}}
            </p>
        {{/observations}}
        <div class="btn-group btn-group-justified" role="group" aria-label="...">
            <div class="btn-group" role="group">
                <button type="button" target="chart-container" class="btn btn-default activate pinfos">Chronologie</button>
            </div>
            <div class="btn-group" role="group">
                <button type="button" target="global-container" class="btn btn-default pinfos">Infos. Parcelle</button>
            </div>
        </div>
        <div class="sections">
            <div class="sub-section chart-container chart" id="chart-container-{{feature_ol_uid}}" style="width: 100%">
                <canvas id="chart-{{feature_ol_uid}}"></canvas>
            </div>
            <div class="sub-section global-container">
                <h4>Parcelle {{idp}}</h4>
                <div class="graph">
                </div>
                <div class="panel panel-default col-xs-1" style="border: 0px">
                    <div class="panel-body panel-graph" style="border: 0px">
                        <img src="apps/bosco/templates/img/plant.svg" style="width:100%;">
                        <p class="title-number">
                            <span id="cn-{{feature_ol_uid}}"></span>
                            <br>
                            <span class="sub-number">
                                <i> Pour l'année <span id="year-{{feature_ol_uid}}"></span></i>
                            </span>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </li>
    <script>

    const statsOGC = mviewer.customComponents["stats-ogc"];

    var chart = null ;
    let thingName = "";
    let thingDescription = "";
    const mvLayer = mviewer.getLayer("{{mviewerid}}").layer;
    const sensorthingsClass = mvLayer.sensorthings;
    let featureWithObservations = mvLayer.sensorthings.features.filter(x => x.ol_uid == {{feature_ol_uid}});
    const props = featureWithObservations[0].getProperties();

    let streamsObs = sensorthingsClass.selectedStreams;
    if(!streamsObs.length) {
        streamsObs = props.sensorthings.observations.map(o => o.id);
    }
    const observations = props.sensorthings.observations
    // DATASTREAM
    let datastreams = props.sensorthings.datastreams;
    let multidatastreams = props.sensorthings.multidatastreams;
    let thing = props.sensorthings.thing;

    var container = document.getElementById("chart-container-{{feature_ol_uid}}");

    // newChart function
    function newChart(title, subtitle) {
       chart = Highcharts.stockChart(container, {
           title: {
               text: title
           },
           subtitle: {
               text: subtitle
           },
           chart: {
               zooming: {
                   type: 'xy'
               }
           },
           legend: {
              enabled: true
           },
           rangeSelector: {
               verticalAlign: 'top',
               y: -35
           },
           plotOptions: {
               series: {
                    showInNavigator: true,
               }
           },
           xAxis : {
               type: 'datetime',
                labels: {
                formatter() {
                    return ' year'
                }
                },
                
           }
       })
       return chart ;
    }

    // newSeries function
    function newSeries (label,unitName,unitSymbol,datesValues,resultsValues) {
        let datasets = [];
        for (var i = 0 ; i < datesValues.length ; i++) {
            datasets[i] = [datesValues[i],resultsValues[i]] ;
        }
        chart.addAxis({
            id: unitName,
            title:{
                text: unitName
            },
            label:{
                format: '{value} '+unitSymbol
            },
            opposite: true,
            rotation: 10
        });
        chart.addSeries({
            yAxis: unitName,
            name: label,
            data: datasets,
            tooltip: {
                valueDecimals: 2,
                valueSuffix: unitSymbol
            }
        });
    }

    if (thing && thing.value && thing.value[0]) {
        thingDescription = thing.value[0].description;
        thingName = thing.value[0].name;
    }
    chart =  newChart(thingName,thingDescription);

    // DATASTREAMS
    if(datastreams && datastreams.length) {
        streamsObs.map(data => {
            let label = datastreams.filter(x => x.name === data)[0]?.name;
            let description = datastreams.filter(x => x.name === data)[0]?.description;
            let unitName = datastreams.filter(x => x.name === data)[0]?.unitOfMeasurement.name;
            let unitSymbol = datastreams.filter(x => x.name === data)[0]?.unitOfMeasurement.symbol;
            let result = _.find(observations, {name: data})?.result;
            if(!data && !result) return;
            let datesValues = result.map(o => new Date(o.phenomenonTime).getTime());
            let resultsValues = result.map(o => o.result);
            newSeries(label,unitName,unitSymbol,datesValues,resultsValues);

        });
    }

    // MULTIDATASTREAMS
    if(multidatastreams && multidatastreams.length) {
        streamsObs.map(data => {
            let dataObservations = _.find(observations, {name: data})?.result || [];
            let yValues = dataObservations.map(o => o.result);
            let unitOfMeasures = multidatastreams[0].unitOfMeasurements.map(x => x.name);
            let unitSymbols = multidatastreams[0].unitOfMeasurements.map(x => x.symbol);
            let unitDefinition = multidatastreams[0].unitOfMeasurements.map(x => x.definition);
            let mapUnitDefinition = new Map();
            let mapUnitSymbol = new Map();
            for (var i = 0 ; i < unitOfMeasures.length ; i++) {
                mapUnitSymbol.set (unitOfMeasures[i],unitSymbols[i]);
                mapUnitDefinition.set (unitOfMeasures[i],unitDefinition[i]);
            }
            var zz=0
            let unitOfMeasurementsDataset = unitOfMeasures.map(unit => {

                let resultsValues = dataObservations.map(o => o.result[zz]);
                zz+=1
                let datesValues = dataObservations.map(o => new Date(o.phenomenonTime).getTime());
                let unitName = mapUnitDefinition.get(unit); ;
                let unitSymbol = mapUnitSymbol.get(unit); ;
                newSeries(unit,unitName,unitSymbol,datesValues,resultsValues);
            });
        })
    }

    const request = (year) => {
        // stats-ogc culture by year
        const nameRequestCulture = "{{feature_ol_uid}}-culture";
        const serviceCulture = "https://api.geosas.fr/stats-ogc/processes/edr-aggregate/execution";
        const paramsCultureByYear = {
            "aggregation": "mode",
            "datetime": "2017-01-01/2022-01-01",
            "url_edr": "https://api.geosas.fr/edr/collections/RPG-Raster"
        };
        const featuresCollection = statsOGC.utils.getSelectedFeaturesByLayerAsJson();
        if(featuresCollection) {
            featuresCollection.crs = {
                properties: {
                    //name: `urn:ogc:def:crs:${mviewer.getMap().getView().getProjection().getCode()}`
                    name: "urn:ogc:def:crs:EPSG::3857"
                },
                type: "name"
            };
        }
        statsOGC.createRequests(nameRequestCulture, featuresCollection, serviceCulture, paramsCultureByYear);
        const req =  statsOGC.getRequests(nameRequestCulture);
        const onReq = (r) => {
            // years
            const cultureByYear = statsOGC.utils.parseResponse(r);
            if(!year) return;
            let infos = cultureByYear.filter(f => {
                const y = moment(f.year, "YYYY-MM-DD-T00-00-00Z").format("YYYY");
                return y == year;
            })[0];
            console.log(infos);
            if(infos) {
                document.querySelector("#cn-{{feature_ol_uid}}").innerHTML = infos.label.fr;
                document.querySelector("#year-{{feature_ol_uid}}").innerHTML = year;
                
            }
            
        }
        req.setProcess(onReq);
        req.requestJson();
    }


    // change layer date on chart click
    document.getElementById("chart-container-{{feature_ol_uid}}").addEventListener('click', e => {
        const layerTimeFilter = document.getElementById("humidite_bzh-layer-timefilter");
        const value = e?.point?.y;
        const formatDate = Highcharts.dateFormat('%Y-%m-%d', e?.point?.x);
        if(formatDate && layerTimeFilter) {
            mviewer.setLayerTime("humidite_bzh", formatDate);
            layerTimeFilter.value = formatDate;
            const year = new Date(formatDate).getFullYear();
            request(year);
        }
    });
    </script>

    <script>
    // button select
    document.querySelectorAll(".el-{{feature_ol_uid}} .pinfos").forEach(x => {
        x.addEventListener("click", ({target}) => {
            document.querySelectorAll(".el-{{feature_ol_uid}} .pinfos").forEach(z => z.classList.remove("activate"));
            target.classList.add("activate");
            const panel = document.querySelectorAll(".activate")[0].attributes.target.value;
            document.querySelectorAll(".sub-section").forEach(e => {e.style.display="none"});
            const panelToShow = document.querySelectorAll(`.sub-section.${panel}`)[0];
            if(panelToShow) {
                panelToShow.style.display = "";
            }
        })
    })
    </script>
    <style>
    .pinfos {
        border: 1px solid rgba(69,90,100, 0.2);
    }
    .pinfos.activate {
        background-color: #455a64;
        color: white;
    }
    </style>
{{/features}}
