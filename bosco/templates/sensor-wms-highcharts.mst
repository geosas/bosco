{{#features}}
	<li id="{{feature_ol_uid}}" class="inventaire item el-{{feature_ol_uid}}" style="height: 330px; overflow:auto;">
        {{#observations}}
            <p>
                <b>Streams sélectionnés : </b> {{streamsNames}}
            </p>
        {{/observations}}
        <div class="btn-group btn-group-justified" role="group" aria-label="...">
            <div class="btn-group" role="group">
                <button type="button" target="chart" class="btn btn-default activate pinfos">Chronologie</button>
            </div>
            <div class="btn-group" role="group">
                <button type="button" target="global" class="btn btn-default pinfos">Infos. Parcelle</button>
            </div>
        </div>
        <div class="sections">
            <div class="sub-section chart-container chart visible" id="chart-container-{{feature_ol_uid}}" style="width: 100%">
                <canvas id="chart-{{feature_ol_uid}}"></canvas>
            </div>
            <div class="sub-section global-container">
            </div>
        </div>
    </li>
    <script>

    var chart = null ;
    let thingName = "";
    let thingDescription = "";
    const mvLayer = mviewer.getLayer("{{mviewerid}}").layer;
    const sensorthingsClass = mvLayer.sensorthings;
    let featureWithObservations = mvLayer.sensorthings.features.filter(x => x.ol_uid == {{feature_ol_uid}});
    const props = featureWithObservations[0].getProperties();

    let streamsObs = sensorthingsClass.selectedStreams;
    if(!streamsObs.length) {
        streamsObs = props.sensorthings.observations.map(o => o.id);
    }
    const observations = props.sensorthings.observations
    // DATASTREAM
    let datastreams = props.sensorthings.datastreams;
    let multidatastreams = props.sensorthings.multidatastreams;
    let thing = props.sensorthings.thing;

    var container = document.getElementById("chart-container-{{feature_ol_uid}}");

    // newChart function
    function newChart(title, subtitle) {
       chart = Highcharts.stockChart(container, {
           title: {
               text: title
           },
           subtitle: {
               text: subtitle
           },
           chart: {
               zooming: {
                   type: 'xy'
               }
           },
           legend: {
              enabled: true
           },
           rangeSelector: {
               verticalAlign: 'top',
               y: -35
           },
           plotOptions: {
               series: {
                    showInNavigator: true,
               }
           },
           xAxis : {
               type: 'datetime',
                labels: {
                formatter() {
                    return ' year'
                }
                },
                
           }
       })
       return chart ;
    }

    // newSeries function
    function newSeries (label,unitName,unitSymbol,datesValues,resultsValues) {
        let datasets = [];
        for (var i = 0 ; i < datesValues.length ; i++) {
            datasets[i] = [datesValues[i],resultsValues[i]] ;
        }
        chart.addAxis({
            id: unitName,
            title:{
                text: unitName
            },
            label:{
                format: '{value} '+unitSymbol
            },
            opposite: true,
            rotation: 10
        });
        chart.addSeries({
            yAxis: unitName,
            name: label,
            data: datasets,
            tooltip: {
                valueDecimals: 2,
                valueSuffix: unitSymbol
            }
        });
    }

    if (thing && thing.value && thing.value[0]) {
        thingDescription = thing.value[0].description;
        thingName = thing.value[0].name;
    }
    chart =  newChart(thingName,thingDescription);

    // DATASTREAMS
    if(datastreams && datastreams.length) {
        streamsObs.map(data => {
            let label = datastreams.filter(x => x.name === data)[0]?.name;
            let description = datastreams.filter(x => x.name === data)[0]?.description;
            let unitName = datastreams.filter(x => x.name === data)[0]?.unitOfMeasurement.name;
            let unitSymbol = datastreams.filter(x => x.name === data)[0]?.unitOfMeasurement.symbol;
            let result = _.find(observations, {name: data})?.result;
            if(!data && !result) return;
            let datesValues = result.map(o => new Date(o.phenomenonTime).getTime());
            let resultsValues = result.map(o => o.result);
            newSeries(label,unitName,unitSymbol,datesValues,resultsValues);

        });
    }

    // MULTIDATASTREAMS
    if(multidatastreams && multidatastreams.length) {
        streamsObs.map(data => {
            let dataObservations = _.find(observations, {name: data})?.result || [];
            let yValues = dataObservations.map(o => o.result);
            let unitOfMeasures = multidatastreams[0].unitOfMeasurements.map(x => x.name);
            let unitSymbols = multidatastreams[0].unitOfMeasurements.map(x => x.symbol);
            let unitDefinition = multidatastreams[0].unitOfMeasurements.map(x => x.definition);
            let mapUnitDefinition = new Map();
            let mapUnitSymbol = new Map();
            for (var i = 0 ; i < unitOfMeasures.length ; i++) {
                mapUnitSymbol.set (unitOfMeasures[i],unitSymbols[i]);
                mapUnitDefinition.set (unitOfMeasures[i],unitDefinition[i]);
            }
            var zz=0
            let unitOfMeasurementsDataset = unitOfMeasures.map(unit => {

                let resultsValues = dataObservations.map(o => o.result[zz]);
                zz+=1
                let datesValues = dataObservations.map(o => new Date(o.phenomenonTime).getTime());
                let unitName = mapUnitDefinition.get(unit); ;
                let unitSymbol = mapUnitSymbol.get(unit); ;
                newSeries(unit,unitName,unitSymbol,datesValues,resultsValues);
            });
        })
    }
    // change layer date on chart click
    document.getElementById("chart-container-{{feature_ol_uid}}").addEventListener('click', e => {
        const layerTimeFilter = document.getElementById("humidite_bzh-layer-timefilter");
        const value = e?.point?.y;
        const formatDate = Highcharts.dateFormat('%Y-%m-%d', e?.point?.x);
        if(formatDate && layerTimeFilter) {
            mviewer.setLayerTime("humidite_bzh", formatDate);
            layerTimeFilter.value = formatDate;
        }
    });

    // stats ogc
    const sta = "https://api.geosas.fr/stats-ogc/processes/sta-aggregate/execution";
    const statsOGC = mviewer.customComponents["stats-ogc"];
    const paramsStats = {
        "aggregation": "mean",
        "echelle": "year",
        "format": "json",
        "url_sensorthings": "https://frost.geosas.fr/bosco/v1.0/Datastreams(3)",
        "year_etude": 2021
    };

    const nameRequestStat = "{{feature_ol_uid}}-stat";
    //mviewer.customComponents["stats-ogc"].createRequests(nameRequestStat, {}, sta, params);


    // stats-ogc culture by year
    const nameRequestCulture = "{{feature_ol_uid}}-culture";
    const serviceCulture = "https://api.geosas.fr/stats-ogc/processes/edr-aggregate/execution";
    const paramsCultureByYear = {
        "aggregation": "mode",
        "datetime": "2017-01-01/2022-01-01",
        "url_edr": "https://api.geosas.fr/edr/collections/RPG-Raster"
    };
    const selectLayer = mviewer.getMap().getLayers().getArray().filter(x => x.get("mviewerid") === "selectoverlay")[0];
    let geometry = null;
    if(selectLayer && selectLayer.getSource().getFeatures()) {
        let writer = new ol.format.GeoJSON();
        let selectedFeatures = selectLayer.getSource().getFeatures();
        // geometry = writer.writeGeometry(selectedFeatures[0].getGeometry());
        // geometry = writer.writeFeatures(selectedFeatures);

        geometry = {
            "crs": {
                "properties": {
                "name": "urn:ogc:def:crs:EPSG::2154"
                },
                "type": "name"
            },
            "features": [
                {
                "geometry": {
                    "coordinates": [
                    [
                        [
                        165189.86264997642,
                        6799939.058717679
                        ],
                        [
                        165189.86264997642,
                        6800198.385465654
                        ],
                        [
                        165371.39137355742,
                        6800198.385465654
                        ],
                        [
                        165371.39137355742,
                        6799939.058717679
                        ],
                        [
                        165189.86264997642,
                        6799939.058717679
                        ]
                    ]
                    ],
                    "type": "Polygon"
                },
                "properties": {},
                "type": "Feature"
                }
            ],
            "name": "parcel",
            "type": "FeatureCollection"
        }
    }
    mviewer.customComponents["stats-ogc"].createRequests(nameRequestCulture, geometry, serviceCulture, paramsCultureByYear);
    const req =  mviewer.customComponents["stats-ogc"].getRequests(nameRequestCulture);
    function getKeyByValue(object, value) {
        return Object.keys(object).find(key => object[key] === value);
    }
    const onReq = (r) => {
        // years
        const years = _.get(r, "response.domain.axes.t.values");
        const cultureCodes = _.get(r, "response.ranges.code_groupe.values");
        const culturesIdByCode = _.get(r, "response.parameters.code_groupe.categoryEncoding");
        const culturesNames = _.get(r, "response.parameters.code_groupe.observedProperty.categories");
        const cultureByYear = years.map((y,i) => {
            const code = cultureCodes[i];
            const year = y;
            const cultureId = getKeyByValue(culturesIdByCode, code);
            const cultureInfos = culturesNames.filter(culture => culture.id === cultureId)[0];
            return {...cultureInfos, year, code};
        });
    }
    req.setProcess(onReq);
    req.requestJson();
    </script>

    <script>
    // button select
    document.querySelectorAll(".el-{{feature_ol_uid}} .pinfos").forEach(x => {
        x.addEventListener("click", ({target}) => {
            document.querySelectorAll(".el-{{feature_ol_uid}} .pinfos").forEach(z => z.classList.remove("activate"));
            target.classList.add("activate");
            const panel = document.querySelectorAll(".activate")[0].attributes.target.value;
            document.querySelectorAll(".sub-section").forEach(e => {e.style.display="none"});
            document.querySelectorAll(".sub-section panel").style.display="";
        })
    })
    </script>
    <style>
    .pinfos {
        border: 1px solid rgba(69,90,100, 0.2);
    }
    .pinfos.activate {
        background-color: #455a64;
        color: white;
    }
    </style>
{{/features}}
